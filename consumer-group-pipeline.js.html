<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: consumer-group-pipeline.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: consumer-group-pipeline.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const Bluebird = require('bluebird');
const {ConsumerGroup} = require('kafka-node');
const {CommitTransformStream} = require('./commit-transform-stream');
const {ConsumeTransformStream} = require('./consume-transform-stream');
const {EventEmitter} = require('events');
const debug = require('debug')('kafka-pipeline:ConsumerGroupPipeline');


const defaultOptions = {
  consumeTimeout: 5000,
  commitInterval: 10000,
  consumeConcurrency: 8
};

const defaultConsumerGroupOption = {
  fetchMaxBytes: 65536,
  sessionTimeout: 15000,
};


class ConsumerGroupPipeline extends EventEmitter {

  /**
   *
   * @param options.topic {String|String[]} A topic or a list of topics
   * @param options.consumerGroupOption {Object} Options passed to internal ConsumerGroup, see kafka-node documentation
   * @param options.consumerGroupOption.groupId {String} Group ID of this consumer
   * @param options.messageConsumer {MessageConsumerCallback} Function to consume message
   * @param [options.failedMessageConsumer] {FailedMessageConsumerCallback} Function to consume message that failed to
   * consume by `messageConsumer`
   * @param [options.consumeTimeout=5000] {Number}
   * @param [options.consumeConcurrency=8] {Number}
   * @param [options.commitInterval=100000] {Number} Time in milliseconds between two commit, suggest to be greater than
   * `consumeTimeout`.
   */
  constructor(options = {}) {
    super();

    if (typeof options !== 'object') {
      throw new TypeError('options is not an object');
    }
    if (typeof options.consumerGroupOption !== 'object') {
      throw new TypeError('missing consumerGroupOptions');
    }
    if (typeof options.consumerGroupOption.groupId !== 'string' || options.consumerGroupOption.groupId === '') {
      throw new TypeError('Invalid groupId');
    }
    this._options = Object.assign({}, defaultOptions, options);

    this._rebalanceCallback = null;
    this._runningPromise = null; // Indicates whether this pipeline is running or closed
  }

  /**
   * Start a consume session, will be destroyed when rebalance or closed
   * @param consumerGroup
   * @param callback
   * @private
   */
  _pipelineSession(consumerGroup, callback) {

    const commitFunction = (offsets) => {
      return new Bluebird((done, fail) => {
        if (offsets.length === 0) {
          return done();
        }
        return consumerGroup.sendOffsetCommitRequest(offsets.map((offset) => {
          return Object.assign({}, {metadata: 'm'}, offset, {metadata: 'm'});
        }), (commitError) => {
          if (commitError) {
            return fail(commitError);
          }
          return done();
        });
      });
    };
    let consumeTransformStreamFull = false;
    const queuedMessages = [];
    const consumeTransformStream = new ConsumeTransformStream({
      groupId: this._options.consumerGroupOption.groupId,
      consumeConcurrency: this._options.consumeConcurrency,
      messageConsumer: this._options.messageConsumer,
      failedMessageConsumer: this._options.failedMessageConsumer,
      consumeTimeout: this._options.consumeTimeout
    });
    const commitTransformStream = new CommitTransformStream({
      commitFunction,
      commitInterval: this._options.commitInterval
    });
    const pumpQueuedMessage = () => {
      if (!this._runningPromise ||
        this._rebalanceCallback ||
        consumeTransformStreamFull
      ) {
        return;
      }
      while (queuedMessages.length > 0) {
        if (!consumeTransformStream.write(queuedMessages.shift())) {
          consumeTransformStreamFull = true;
          return;
        }
      }
      consumerGroup.resume();
    };
    const onFetchCompleted = () => {
      consumerGroup.pause();
      pumpQueuedMessage();
    };
    const onMessage = (message) => {
      queuedMessages.push(message);
    };

    const cleanUpAndExit = (e) => {
      consumeTransformStream.removeAllListeners();
      commitTransformStream.removeAllListeners();
      consumerGroup.removeListener('message', onMessage);
      consumerGroup.removeListener('done', onFetchCompleted);
      consumerGroup.removeAllListeners('error');
      callback(e);
    };

    consumerGroup.once('error', (e) => {
      debug('Error occurred for consumer group: ', e);
      cleanUpAndExit(e);
    });

    consumeTransformStream.once('error', (e) => {
      debug('Error occurred for consumeTransformStream: ', e);
      cleanUpAndExit(e);
    });

    commitTransformStream.once('error', (e) => {
      debug('Error occurred for commitTransformStream: ', e);
      cleanUpAndExit(e);
    });

    commitTransformStream.once('end', () => {
      cleanUpAndExit(null);
    }).resume();


    consumerGroup.on('message', onMessage);
    consumerGroup.on('done', onFetchCompleted);

    consumeTransformStream.on('drain', () => {
      consumeTransformStreamFull = false;
      pumpQueuedMessage();
    });

    consumeTransformStream.pipe(commitTransformStream);
    this._consumeTransformStream = consumeTransformStream;
  }

  /**
   * Maintaining lifecycle
   * @param consumerGroup
   * @param callback {Function} A function will be called when consuming pipeline is closed
   * @private
   */
  _pipelineLifecycle(consumerGroup, callback) {

    return this._pipelineSession(consumerGroup, (e) => {
      if (e) {
        return consumerGroup.close(() => {
          callback(e);
        });
      }

      if (this._rebalanceCallback) {
        const rebalanceCallback = this._rebalanceCallback;
        this._rebalanceCallback = null;

        // This pipeline is closed due to rebalance, we need to call `rebalanceCallback`
        // and restart a new pipeline and pass origin `callback` through

        this._pipelineLifecycle(consumerGroup, callback);
        return rebalanceCallback();
      }

      return consumerGroup.close(callback);
    });
  }


  /**
   * Start consuming message until close being called
   *
   * @param callback {Function} A function will be called when consuming pipeline is closed
   * @private
   */
  _consumeForever(callback) {

    const onRebalance = (isMember, rebalanceCallback) => {
      if (!(isMember &amp;&amp; this._runningPromise)) {
        rebalanceCallback();
        return;
      }
      this._rebalanceCallback = rebalanceCallback;
      // This function will finally triggered 'end' event of commit transform stream
      process.nextTick(() => this._consumeTransformStream.end());
    };

    const consumerGroupOptions = Object.assign(
      {},
      defaultConsumerGroupOption,
      this._options.consumerGroupOption,
      {
        onRebalance,
        autoCommit: false,
        paused: false,
        connectOnReady: true,
      }
    );

    const consumerGroup = new ConsumerGroup(consumerGroupOptions, [this._options.topic]);

    consumerGroup.on('rebalanced', () => {
      if (consumerGroup.paused) {
        consumerGroup.resume();
      }
    });

    this._pipelineLifecycle(consumerGroup, callback);
  }

  /**
   * Start consuming
   */
  start() {

    if (this._runningPromise) {
      return;
    }
    this._runningPromise = Bluebird
      .fromCallback((done) => {
        this._consumeForever((e) => {
          if (e) {
            return done(e);
          }
          return done();
        });
      })
      .catch((e) => {
        this.emit('error', e);
      })
      .finally(() => {
        this.emit('close');
      })
    ;
  }

  /**
   * Stop consuming
   * @returns {Promise}
   */
  close() {
    if (!this._runningPromise) {
      return Bluebird.resolve(null);
    }
    const runningPromise = this._runningPromise;
    this._runningPromise = null;

    process.nextTick(() => this._consumeTransformStream.end());
    return runningPromise;
  }
}

module.exports = {ConsumerGroupPipeline};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ConsumerGroupPipeline.html">ConsumerGroupPipeline</a></li><li><a href="ConsumeTimeoutError.html">ConsumeTimeoutError</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Oct 26 2018 14:11:13 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
